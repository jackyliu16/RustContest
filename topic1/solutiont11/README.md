# 设计思路:

针对于分配器的其中一个特性的最简单实现,仅仅相当于对于伙伴分配器的多次复用,尚未有足够时间完成这个题目





# 论文节选

分配器的一个日益增长的用例是作为语言的后端实现，它们使用引用计数来自动释放对象。
mimalloc，这是一种内存分配器，可以有效地平衡这些需求，与现有分配器相比具有显著的性能优势，并且专为支持依赖内存分配器作为参考计数后端的语言而量身定制

它使用三个页面本地分片免费列表来增加位置性，避免争用，并支持高度优化的 allocate 和 free 快速路径,
空闲列表还支持 temporal cadence 以允许分配器以可预测的方式向常规维护任务提供快速路径 (例如支持延迟释放、处理来自非本地线程的释放等)

## Trans

其主要思想是使用极端的空闲列表分片：
    而不是每个大小类一个大的空闲列表，
    而是每个mimalloc页面一个空闲列表（通常为64KiB）。 
    这保持了分配的局部性，因为malloc在一个页面内分配，直到该页面已满，而不管其他对象在堆中的何处被释放。

此外，我们使用单独的线程空闲列表来释放其他线程，以避免在malloc的快速路径中进行原子操作。
这些无线程列表也是按页分片的，以最大限度地减少它们之间的争用。 
这样的列表每隔一段时间被原子地移动到本地空闲列表，这有效地批处理远程空闲（Liétar等人， 2019年度）

最后，我们在每个页面上使用第三个本地空闲列表来释放线程本地空闲。 分配空闲时列表为空时，
本地空闲列表将成为新的空闲列表。 此设计可确保在固定数量的分配之后，始终采用通用分配路径，从而建立
时间节奏。 此例程现在可用于摊销更昂贵的操作：

1 对于延迟的引用计数器递减进行释放，
2）维持确定性心跳，
3）收集并发线程空闲列表。 因此，使用单独的本地空闲列表可以 ,我们在快速分配路径中进行一次检查，以处理上述所有情况
通用“收集”例程。

我们高度优化了公共分配和自由代码路径，并遵循泛型在其他情况下的常规。 这意味着数据结构需要非常规则，以便
最小化快速路径中的条件。这种一致的设计还减少了特殊情况， 增加代码重用-导致更规则和更简单的代码。 
核心库小于 3500兆，远小于其他行业实力分配器的核心，如tcmalloc （~ 20 k）和jemalloc（~ 25 k）

没有锁，所有的线程交互都是使用原子操作完成的。 它有界最坏情况下的分配时间，元数据开销约为0.2%，最多为16.7%（18日） 分配大小类中的浪费。

从历史上看，分配器设计重点关注性能问题，例如减少分配器中的时间、减少内存使用或扩展到许多并发线程。 
分配器设计的主要动机是提高应用程序的引用局部性，但这种情况不太常见。 
例如，VAM（Feng and Berger，2005）和PHKmalloc的早期版本也使用自由列表分片来确保顺序分配通常来自同一页面。 
mimalloc还改进了应用程序内存引用局部性，并通过实现多线程和添加额外的分片空闲列表来改进VAM，以减少争用并支持分摊维护任务。 
我们的设计表明，分配器专注于提高应用程序的内存局部性，也可以提供高分配器的性能和并发的可扩展性。
在本文的其余部分，我们提出了mimalloc的设计，包括激励三个自由列表，考虑安全性和可移植性等问题，
并评估其性能对许多国家的最先进的分配器实现。 mimalloc是用C实现的，可以在Linux、FreeBSD、MacOSX和Windows上运行，并
且可以在github上免费获得（Leijen，2019 b），并且具有简化和常规的代码库，特别适合集成到其他语言的运行时中

2. 免费列表共享
   首先，我们将概述空闲列表分片、本地空闲列表和线程空闲的具体内容
   名单 在此之后，第3节将详细介绍整个堆布局（图1）和实现
   malloc和free的性能指标评测结果，然后是第4节中的性能指标评测结果
3. 函数式编程的分配模式是分配和释放许多小对象。
   许多分配器对每个大小类使用一个空闲列表，这会导致空间局部性不好，
   属于单个结构的对象可以分布在整个堆上。 考虑例如
   下面的堆状态（A），其中空闲列表跨越堆的大部分